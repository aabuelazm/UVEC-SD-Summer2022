#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl9,  sFront,         sensorSONAR_mm)
#pragma config(Sensor, dgtl11, sBack,          sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  sArm,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  sArm1,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  sClaw,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mDrive,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mArm,          tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           mArm1,         tmotorVex393_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port4,           mClaw,         tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define WHEEL_SPEED -100
#define ARM_SPEED -127
#define ARM_DISTANCE 100
#define ARM_DROP -2500
#define CLAW_SPEED 50
#define CLAW_DISTANCE 40
#define CLOSE_CLAW 50

enum SystemPhase {
	idle,
	moveFore,
	pickup,
	moveBack,
	egg
};
SystemPhase phase = idle;

task main() {
	slaveMotor(mArm1, mArm);
	moveMotorTarget(mArm, 0, 127, true);
	bool done = false;

	// main loop
	while(!done){
		switch (phase) {
		case idle:
			if (SensorValue[button]) {
				motor[mDrive] = WHEEL_SPEED;
				phase = moveFore;
				delay(2000);
			}
			break;

		case moveFore:
			if (SensorValue[sFront] <= CLAW_DISTANCE) {
				motor[mDrive] = 0;
				phase = pickup;
				delay(2000);
			}
			break;

		case pickup:
			motor[mClaw] = CLAW_SPEED;
			while (SensorValue[sClaw] <= CLOSE_CLAW) {}
			motor[mClaw] = 0;
			motor[mDrive] = -WHEEL_SPEED;
			phase = moveBack;
			delay(2000);
			break;

		case moveBack:
			if (SensorValue[sBack] <= ARM_DISTANCE) {
				motor[mDrive] = 0;
				phase = egg;
				delay(2000);
			}
			break;

		case egg:
			moveMotorTarget(mArm, ARM_DROP, 100, true);
			while(!getMotorTargetCompleted(mArm)) {}
			phase = idle;
			delay(2000);
			done = true;
			break;
		}
	}
}
